function m(e){return e()}function k(e){e.forEach(m)}const l=[],v=[],a=[],p=[],b=Promise.resolve();let f=!1;function O(){f||(f=!0,b.then(I))}function y(){return O(),b}function C(e){a.push(e)}const h=new Set;let o=0;function I(){do{for(;o<l.length;){const e=l[o];o++,R(e.$$)}for(l.length=0,o=0;v.length;)v.pop()();for(let e=0;e<a.length;e+=1){const t=a[e];h.has(t)||(h.add(t),t())}a.length=0}while(l.length);for(;p.length;)p.pop()();f=!1,h.clear()}function R(e){if(e.fragment!==null){e.update(),k(e.before_update);const t=e.dirty;e.dirty=[-1],e.fragment&&e.fragment.p(e.ctx,t),e.after_update.forEach(C)}}const z={root:null,rootMargin:"0px",threshold:0,unobserveOnEnter:!1},n=(e,t)=>new CustomEvent(e,{detail:t});function j(e,t={}){const{root:g,rootMargin:_,threshold:w,unobserveOnEnter:x}=Object.assign(Object.assign({},z),t);let u={x:void 0,y:void 0},r={vertical:void 0,horizontal:void 0};if(typeof IntersectionObserver<"u"&&e){const s=new IntersectionObserver((E,d)=>{E.forEach(i=>{u.y>i.boundingClientRect.y?r.vertical="up":r.vertical="down",u.x>i.boundingClientRect.x?r.horizontal="left":r.horizontal="right",u={y:i.boundingClientRect.y,x:i.boundingClientRect.x};const c={inView:i.isIntersecting,entry:i,scrollDirection:r,node:e,observer:d};e.dispatchEvent(n("inview_change",c)),e.dispatchEvent(n("change",c)),i.isIntersecting?(e.dispatchEvent(n("inview_enter",c)),e.dispatchEvent(n("enter",c)),x&&d.unobserve(e)):(e.dispatchEvent(n("inview_leave",c)),e.dispatchEvent(n("leave",c)))})},{root:g,rootMargin:_,threshold:w});return y().then(()=>{e.dispatchEvent(n("inview_init",{observer:s,node:e})),e.dispatchEvent(n("init",{observer:s,node:e}))}),s.observe(e),{destroy(){s.unobserve(e)}}}}export{j as i};
